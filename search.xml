<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Golang中slice的使用技巧]]></title>
    <url>%2Farticles%2FGolang%E4%B8%ADslice%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[由于引入了内建的append方法，container/vector包的很多方法在Go 1中被移除了，因为我们认为可以通过使用append和copy来代替它们。 下面就是container/vector包中的方法，我们通过slice来模拟实现。 常规操作1. Append Vector1a = append(a, b...) 2. Copy123456b = make([]T, len(a))copy(b, a)// orb = append([]T(nil), a...)// orb = append(a[:0:0], a...) // 查看 https://github.com/go101/go101/wiki 3. Cut1a = append(a[:i], a[j:]...) 4. Delete123a = append(a[:i], a[i+1:]...)// ora = a[:i+copy(a[i:], a[i+1:])] 5. Delete without preserving order12a[i] = a[len(a)-1] a = a[:len(a)-1] 注意: 如果该元素类型是一个指针，或者是一个包含需要被回收的指针类型字段的struct，上面的cut、delete实现可能会有潜在的内存泄漏的问题。一些元素的值可能会被a一直引用而不被释放，下面的代码可以解决这个问题。 12345678910111213141516// Cutcopy(a[i:], a[j:])for k, n := len(a)-j+i, len(a); k &lt; n; k++ &#123; a[k] = nil // 或者类型T的对应零值&#125;a = a[:len(a)-j+i]// Deletecopy(a[i:], a[i+1:])a[len(a)-1] = nil // 或者类型T的对应零值a = a[:len(a)-1]// 不保证原来顺序的Deletea[i] = a[len(a)-1]a[len(a)-1] = nila = a[:len(a)-1] 6. Expand1a = append(a[:i], append(make([]T, j), a[i:]...)...) 7. Extend1a = append(a, make([]T, j)...) 8. Insert1a = append(a[:i], append([]T&#123;x&#125;, a[i:]...)...) 注意: 第二个append（指的👆代码块的中append([]T{x}, a[i:]...)）会利用原来slice底层的数组创建一个新的slice，然后将a[i:]中的元素copy到这个新的slice，最后再把这个新的slice复制回原来的a。 新的slice的创建（随之带来了多余的内存回收压力）和copy可以使用下面的方式来避免： 1234// Inserts = append(s, 0)copy(s[i+1:], s[i:])s[i] = x 9. InsertVector1a = append(a[:i], append(b, a[i:]...)...) 10. Pop/Shift1x, a = a[0], a[1:] 11. Pop Back1x, a = a[len(a)-1], a[:len(a)-1] 12. Push1a = append(a, x) 13. Push Front/Unshift1a = append([]T&#123;x&#125;, a...) 一些奇技淫巧（前方高能……orz）1. 无额外对象分配的filter这个技巧利用了slice会共享它底层数据存储和容量的特性，通过重用底层存储来过滤slice。当然了，原slice的内容也会相应发生改变。 123456b := a[:0]for _, x := range a &#123; if f(x) &#123; b = append(b, x) &#125;&#125; 2. 反转将slice中的元素反转。 1234for i := len(a)/2-1; i &gt;= 0; i-- &#123; opp := len(a)-1-i a[i], a[opp] = a[opp], a[i]&#125; 下面的代码类似，只不过使用了两个游标。 123for left, right := 0, len(a)-1; left &lt; right; left, right = left+1, right-1 &#123; a[left], a[right] = a[right], a[left]&#125; 3. 洗牌Fisher–Yates算法。 从go1.10开始，已经在包math/rand.Shuffle中原生支持了。 1234for i := len(a) - 1; i &gt; 0; i-- &#123; j := rand.Intn(i + 1) a[i], a[j] = a[j], a[i]&#125; 4. 最小化内存使用的批量处理方法如果你想分批处理一个很大的slice，这个技巧会很有用！ 1234567891011actions := []int&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;batchSize := 3var batches [][]intfor batchSize &lt; len(actions) &#123; actions, batches = actions[batchSize:], append(batches, actions[0:batchSize:batchSize])&#125;batches = append(batches, actions)fmt.Println(result)// [[0 1 2] [3 4 5] [6 7 8] [9]] 5. in-place 去重法123456789101112131415import "sort"in := []int&#123;3,2,1,4,3,2,1,4,1&#125; // 任何实现了sort接口的类型都可以sort.Ints(in)j := 0for i := 1; i &lt; len(in); i++ &#123; if in[j] == in[i] &#123; continue &#125; j++ in[i], in[j] = in[j], in[i]&#125;result := in[:j+1]fmt.Println(result) // [1 2 3 4] 注：本文源自Golang官方Wiki文章，且在不定期更新，本人也会持续跟进～]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>slice</tag>
        <tag>tricks</tag>
      </tags>
  </entry>
</search>
