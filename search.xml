<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[宏观视角看Golang中Map的内部实现]]></title>
    <url>%2Farticles%2F%E5%AE%8F%E8%A7%82%E8%A7%86%E8%A7%92%E7%9C%8BGolang%E4%B8%AD%E7%9A%84Map%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[介绍网上已经有很多关于slices内部实现的文章。但是每次一说到map，我们好像就一脸懵哔了。我想知道为什么，然后我就去翻看了map的源码，最终一切都真相大白了。orz…. 至少对我来说，这些源码是有点复杂的。话虽如此，我认为我们还是可以从一个宏观的视角来看看map到底是如何构建和扩容的。并且这至少要能够解释map为什么是无序的、高效的、快速的。 创建和使用map首先让我们来看看，如何创建一个map并在其中存储一些值： 1234567// Create an empty map with a key and value of type stringcolors := map[string]string&#123;&#125;// Add a few keys/value pairs to the mapcolors["AliceBlue"] = "#F0F8FF"colors["Coral"] = "#FF7F50"colors["DarkGray"] = "#A9A9A9" 当我们想向map添加一些值时，我们总是会给每个值指定一个key。每个key是为了让我们后续可以在不遍历整个集合的前提下快速的查到对应的值。 1fmt.Printf("Value: %s", colors["Coral"]) 如果我们遍历整个map，我们取到的值的顺序不一定会和我们当初存进去的顺序一致。事实上，每次执行以下代码，所得到的顺序都会不一样： 12345678910111213141516171819colors := map[string]string&#123;&#125;colors["AliceBlue"] = "#F0F8FF"colors["Coral"] = "#FF7F50"colors["DarkGray"] = "#A9A9A9"colors["ForestGreen"] = "#228B22"colors["Indigo"] = "#4B0082"colors["Lime"] = "#00FF00"colors["Navy"] = "#000080"colors["Orchid"] = "#DA70D6"colors["Salmon"] = "#FA8072"for key, value := range colors &#123; fmt.Printf("%s:%s, ", key, value)&#125;//Output://AliceBlue:#F0F8FF, DarkGray:#A9A9A9, Indigo:#4B0082, Coral:#FF7F50,//ForestGreen:#228B22, Lime:#00FF00, Navy:#000080, Orchid:#DA70D6,//Salmon:#FA8072 现在，我们已经学会如何创建一个map，并对其进行设置和遍历了。接下来，让我们揭开这一切的面纱。：） map的内部结构Go中的map是通过hash table实现的。如果你还不知道hash table是什么，网上已经有很多相关的文章了。或许你可以从Wiki开始。 Go map的hash table是一个桶数组。桶的数量总是设置成2的乘方。当你执行一个map操作的时候，比如（colors[“Black”] = “#000000”）,一个指向相应值的hash key就会生成。在这个例子中，字符串”Black”就是用来生成hash key的。所生成的hash key的低位字节用来定位到哪一个桶。 桶定位好了之后，就可以存储、移除、查找键值对了。如果我们进一步看看桶的内部实现，就会发现它是由两部分组成的。其一，在这个hash key中有一个位数组，它的高八位用来定位到桶。这个数组保证了存储在各自桶中的键值对不会重复。其二，有一个字节数组，其中存储了所有的键值对。这个数组讲所有的键，所有的值分别打包存放在各自的桶中。 当我们遍历一个map的时候，迭代器依次访问所有的桶，然后按照它们在字节数组中的顺序依次返回键值对。这就是为什么map的输出是无序集合。hash keys决定了map的遍历顺序，因为它们决定了每个键值对最终会进入哪个桶。 内存和桶溢出键值对之所以要这样打包存放在一个字节数组中，有一个很重要的原因。那就是，假如所有的键、值都按照key/value/key/value的方式存储，在每个键值对之间就需要去额外填充适当的空间，才能够保持内存边界对齐。举个🌰，我们申明如下这样的一个map： 1map[int64]int8 这个map的每一个键值对中，一个字节大小的值都会导致7个字节的额外填充。而通过将键值对以key/key/value/value的方式存储，唯一可能需要额外填充的地方就是在字节数组的最后，而不是之间。消除这些不必要的填充字节，帮助桶和map省了很多的内存开销。想要学习更多边界对齐相关的知识，可以读读这篇文章。 每个桶配置成了只能存储8个键值对。如果有第九个键值对需要加入到这个已经满了的桶中时，一个新的桶就会被创建，并被各自的桶所引用。 map扩容当我们持续的对一个map添加/删除键值对时，map的性能会开始下降。决定了一个map何时触发扩容的负载阈值是由以下四个因子决定的： 1234overflow : Percentage of buckets which have an overflow bucketbytes/entry : Number of overhead bytes used per key/value pairhitprobe : Number of entries that need to be checked when looking up a keymissprobe : Number of entries that need to be checked when looking up an absent key 目前，源码中用的具体的负载阈值如下： LOAD %overflow bytes/entry hitprobe missprobe 6.50 20.90 10.79 4.25 6.50 发生扩容时，首先申请一个指针指向旧桶的地址。然后分配一个二倍于原来桶数量的桶数组。这会导致出现大量的内存分配，但是因为这些申请的内存并没有初始化，所以这些分配时很快的。 一旦新的桶数组的内存可用了，旧的桶数组中的所有键值对就可以搬到新的桶数组中去了。每次搬迁发生在map新增/移除键值对的时候。在旧桶数组中的同一个桶的键值对可能被搬运到新桶数组的不同的桶中去。搬运算法试图让键值对均匀的分布在新的桶数组中。 这是一个非常精巧的设计，因为迭代器仍然需要去遍历旧的桶，直到旧的桶全部搬运完毕。在迭代操作的过程中，键值对的返回方式也受到了这一设计的影响。采用了很多方案来确保在map扩容的过程中迭代器能正常工作。 总结正如开头所说的，这篇文章只是在一个宏观的视角下看map的内部结构和它是如何扩容的。源码是用c写的，使用了很多的内存和指针操作来保证效率和可靠。 当然了，现在的实现方式在未来的任何一个时间都可能会发生改变。但是这并不影响我们正确使用map的能力。这个视角让我们明白了，当我们提前知道会有多少key需要存储时，最好在初始化的时候就把相应大小的内存分配好。同时也解释了为什么map是一个无序的集合，和为什么在遍历map的时候，迭代器的行为看起来像是随机的。 此文为译文，原文地址。]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>map</tag>
        <tag>internals</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang中slice的使用技巧]]></title>
    <url>%2Farticles%2FGolang%E4%B8%ADslice%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[由于引入了内建的append方法，container/vector包的很多方法在Go 1中被移除了，因为我们认为可以通过使用append和copy来代替它们。 下面就是container/vector包中的方法，我们通过slice来模拟实现。 常规操作Append Vector1a = append(a, b...) Copy123456b = make([]T, len(a))copy(b, a)// orb = append([]T(nil), a...)// orb = append(a[:0:0], a...) // 查看 https://github.com/go101/go101/wiki Cut1a = append(a[:i], a[j:]...) Delete123a = append(a[:i], a[i+1:]...)// ora = a[:i+copy(a[i:], a[i+1:])] Delete without preserving order12a[i] = a[len(a)-1] a = a[:len(a)-1] 注意: 如果该元素类型是一个指针，或者是一个包含需要被回收的指针类型字段的struct，上面的cut、delete实现可能会有潜在的内存泄漏的问题。一些元素的值可能会被a一直引用而不被释放，下面的代码可以解决这个问题。 12345678910111213141516// Cutcopy(a[i:], a[j:])for k, n := len(a)-j+i, len(a); k &lt; n; k++ &#123; a[k] = nil // 或者类型T的对应零值&#125;a = a[:len(a)-j+i]// Deletecopy(a[i:], a[i+1:])a[len(a)-1] = nil // 或者类型T的对应零值a = a[:len(a)-1]// 不保证原来顺序的Deletea[i] = a[len(a)-1]a[len(a)-1] = nila = a[:len(a)-1] Expand1a = append(a[:i], append(make([]T, j), a[i:]...)...) Extend1a = append(a, make([]T, j)...) Insert1a = append(a[:i], append([]T&#123;x&#125;, a[i:]...)...) 注意: 第二个append（指的👆代码块的中append([]T{x}, a[i:]...)）会利用原来slice底层的数组创建一个新的slice，然后将a[i:]中的元素copy到这个新的slice，最后再把这个新的slice复制回原来的a。 新的slice的创建（随之带来了多余的内存回收压力）和copy可以使用下面的方式来避免： 1234// Inserts = append(s, 0)copy(s[i+1:], s[i:])s[i] = x InsertVector1a = append(a[:i], append(b, a[i:]...)...) Pop/Shift1x, a = a[0], a[1:] Pop Back1x, a = a[len(a)-1], a[:len(a)-1] Push1a = append(a, x) Push Front/Unshift1a = append([]T&#123;x&#125;, a...) 一些奇技淫巧（前方高能……orz）无额外对象分配的filter这个技巧利用了slice会共享它底层数据存储和容量的特性，通过重用底层存储来过滤slice。当然了，原slice的内容也会相应发生改变。 123456b := a[:0]for _, x := range a &#123; if f(x) &#123; b = append(b, x) &#125;&#125; 反转将slice中的元素反转。 1234for i := len(a)/2-1; i &gt;= 0; i-- &#123; opp := len(a)-1-i a[i], a[opp] = a[opp], a[i]&#125; 下面的代码类似，只不过使用了两个游标。 123for left, right := 0, len(a)-1; left &lt; right; left, right = left+1, right-1 &#123; a[left], a[right] = a[right], a[left]&#125; 洗牌Fisher–Yates算法。 从go1.10开始，已经在包math/rand.Shuffle中原生支持了。 1234for i := len(a) - 1; i &gt; 0; i-- &#123; j := rand.Intn(i + 1) a[i], a[j] = a[j], a[i]&#125; 最小化内存使用的批量处理方法如果你想分批处理一个很大的slice，这个技巧会很有用！ 1234567891011actions := []int&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;batchSize := 3var batches [][]intfor batchSize &lt; len(actions) &#123; actions, batches = actions[batchSize:], append(batches, actions[0:batchSize:batchSize])&#125;batches = append(batches, actions)fmt.Println(result)// [[0 1 2] [3 4 5] [6 7 8] [9]] in-place 去重法123456789101112131415import "sort"in := []int&#123;3,2,1,4,3,2,1,4,1&#125; // 任何实现了sort接口的类型都可以sort.Ints(in)j := 0for i := 1; i &lt; len(in); i++ &#123; if in[j] == in[i] &#123; continue &#125; j++ in[i], in[j] = in[j], in[i]&#125;result := in[:j+1]fmt.Println(result) // [1 2 3 4] 注：本文源自Golang官方Wiki文章，且在不定期更新，本人也会持续跟进～]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>slice</tag>
        <tag>tricks</tag>
      </tags>
  </entry>
</search>
