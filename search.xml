<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[å®è§‚è§†è§’çœ‹Golangä¸­Mapçš„å†…éƒ¨å®žçŽ°]]></title>
    <url>%2Farticles%2F%E5%AE%8F%E8%A7%82%E8%A7%86%E8%A7%92%E7%9C%8BGolang%E4%B8%AD%E7%9A%84Map%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[1. ä»‹ç»ç½‘ä¸Šå·²ç»æœ‰å¾ˆå¤šå…³äºŽsliceså†…éƒ¨å®žçŽ°çš„æ–‡ç« ã€‚ä½†æ˜¯æ¯æ¬¡ä¸€è¯´åˆ°mapï¼Œæˆ‘ä»¬å¥½åƒå°±ä¸€è„¸æ‡µå“”äº†ã€‚æˆ‘æƒ³çŸ¥é“ä¸ºä»€ä¹ˆï¼Œç„¶åŽæˆ‘å°±åŽ»ç¿»çœ‹äº†mapçš„æºç ï¼Œæœ€ç»ˆä¸€åˆ‡éƒ½çœŸç›¸å¤§ç™½äº†ã€‚orzâ€¦. è‡³å°‘å¯¹æˆ‘æ¥è¯´ï¼Œè¿™äº›æºç æ˜¯æœ‰ç‚¹å¤æ‚çš„ã€‚è¯è™½å¦‚æ­¤ï¼Œæˆ‘è®¤ä¸ºæˆ‘ä»¬è¿˜æ˜¯å¯ä»¥ä»Žä¸€ä¸ªå®è§‚çš„è§†è§’æ¥çœ‹çœ‹mapåˆ°åº•æ˜¯å¦‚ä½•æž„å»ºå’Œæ‰©å®¹çš„ã€‚å¹¶ä¸”è¿™è‡³å°‘è¦èƒ½å¤Ÿè§£é‡Šmapä¸ºä»€ä¹ˆæ˜¯æ— åºçš„ã€é«˜æ•ˆçš„ã€å¿«é€Ÿçš„ã€‚ 2. åˆ›å»ºå’Œä½¿ç”¨mapé¦–å…ˆè®©æˆ‘ä»¬æ¥çœ‹çœ‹ï¼Œå¦‚ä½•åˆ›å»ºä¸€ä¸ªmapå¹¶åœ¨å…¶ä¸­å­˜å‚¨ä¸€äº›å€¼ï¼š 1234567// Create an empty map with a key and value of type stringcolors := map[string]string&#123;&#125;// Add a few keys/value pairs to the mapcolors["AliceBlue"] = "#F0F8FF"colors["Coral"] = "#FF7F50"colors["DarkGray"] = "#A9A9A9" å½“æˆ‘ä»¬æƒ³å‘mapæ·»åŠ ä¸€äº›å€¼æ—¶ï¼Œæˆ‘ä»¬æ€»æ˜¯ä¼šç»™æ¯ä¸ªå€¼æŒ‡å®šä¸€ä¸ªkeyã€‚æ¯ä¸ªkeyæ˜¯ä¸ºäº†è®©æˆ‘ä»¬åŽç»­å¯ä»¥åœ¨ä¸éåŽ†æ•´ä¸ªé›†åˆçš„å‰æä¸‹å¿«é€Ÿçš„æŸ¥åˆ°å¯¹åº”çš„å€¼ã€‚ 1fmt.Printf("Value: %s", colors["Coral"]) å¦‚æžœæˆ‘ä»¬éåŽ†æ•´ä¸ªmapï¼Œæˆ‘ä»¬å–åˆ°çš„å€¼çš„é¡ºåºä¸ä¸€å®šä¼šå’Œæˆ‘ä»¬å½“åˆå­˜è¿›åŽ»çš„é¡ºåºä¸€è‡´ã€‚äº‹å®žä¸Šï¼Œæ¯æ¬¡æ‰§è¡Œä»¥ä¸‹ä»£ç ï¼Œæ‰€å¾—åˆ°çš„é¡ºåºéƒ½ä¼šä¸ä¸€æ ·ï¼š 12345678910111213141516171819colors := map[string]string&#123;&#125;colors["AliceBlue"] = "#F0F8FF"colors["Coral"] = "#FF7F50"colors["DarkGray"] = "#A9A9A9"colors["ForestGreen"] = "#228B22"colors["Indigo"] = "#4B0082"colors["Lime"] = "#00FF00"colors["Navy"] = "#000080"colors["Orchid"] = "#DA70D6"colors["Salmon"] = "#FA8072"for key, value := range colors &#123; fmt.Printf("%s:%s, ", key, value)&#125;//Output://AliceBlue:#F0F8FF, DarkGray:#A9A9A9, Indigo:#4B0082, Coral:#FF7F50,//ForestGreen:#228B22, Lime:#00FF00, Navy:#000080, Orchid:#DA70D6,//Salmon:#FA8072 çŽ°åœ¨ï¼Œæˆ‘ä»¬å·²ç»å­¦ä¼šå¦‚ä½•åˆ›å»ºä¸€ä¸ªmapï¼Œå¹¶å¯¹å…¶è¿›è¡Œè®¾ç½®å’ŒéåŽ†äº†ã€‚æŽ¥ä¸‹æ¥ï¼Œè®©æˆ‘ä»¬æ­å¼€è¿™ä¸€åˆ‡çš„é¢çº±ã€‚ï¼šï¼‰ 3. mapçš„å†…éƒ¨ç»“æž„Goä¸­çš„mapæ˜¯é€šè¿‡hash tableå®žçŽ°çš„ã€‚å¦‚æžœä½ è¿˜ä¸çŸ¥é“hash tableæ˜¯ä»€ä¹ˆï¼Œç½‘ä¸Šå·²ç»æœ‰å¾ˆå¤šç›¸å…³çš„æ–‡ç« äº†ã€‚æˆ–è®¸ä½ å¯ä»¥ä»ŽWikiå¼€å§‹ã€‚ Go mapçš„hash tableæ˜¯ä¸€ä¸ªæ¡¶æ•°ç»„ã€‚æ¡¶çš„æ•°é‡æ€»æ˜¯è®¾ç½®æˆ2çš„ä¹˜æ–¹ã€‚å½“ä½ æ‰§è¡Œä¸€ä¸ªmapæ“ä½œçš„æ—¶å€™ï¼Œæ¯”å¦‚ï¼ˆcolors[â€œBlackâ€] = â€œ#000000â€ï¼‰,ä¸€ä¸ªæŒ‡å‘ç›¸åº”å€¼çš„hash keyå°±ä¼šç”Ÿæˆã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œå­—ç¬¦ä¸²â€Blackâ€å°±æ˜¯ç”¨æ¥ç”Ÿæˆhash keyçš„ã€‚æ‰€ç”Ÿæˆçš„hash keyçš„ä½Žä½å­—èŠ‚ç”¨æ¥å®šä½åˆ°å“ªä¸€ä¸ªæ¡¶ã€‚ æ¡¶å®šä½å¥½äº†ä¹‹åŽï¼Œå°±å¯ä»¥å­˜å‚¨ã€ç§»é™¤ã€æŸ¥æ‰¾é”®å€¼å¯¹äº†ã€‚å¦‚æžœæˆ‘ä»¬è¿›ä¸€æ­¥çœ‹çœ‹æ¡¶çš„å†…éƒ¨å®žçŽ°ï¼Œå°±ä¼šå‘çŽ°å®ƒæ˜¯ç”±ä¸¤éƒ¨åˆ†ç»„æˆçš„ã€‚å…¶ä¸€ï¼Œåœ¨è¿™ä¸ªhash keyä¸­æœ‰ä¸€ä¸ªä½æ•°ç»„ï¼Œå®ƒçš„é«˜å…«ä½ç”¨æ¥å®šä½åˆ°æ¡¶ã€‚è¿™ä¸ªæ•°ç»„ä¿è¯äº†å­˜å‚¨åœ¨å„è‡ªæ¡¶ä¸­çš„é”®å€¼å¯¹ä¸ä¼šé‡å¤ã€‚å…¶äºŒï¼Œæœ‰ä¸€ä¸ªå­—èŠ‚æ•°ç»„ï¼Œå…¶ä¸­å­˜å‚¨äº†æ‰€æœ‰çš„é”®å€¼å¯¹ã€‚è¿™ä¸ªæ•°ç»„è®²æ‰€æœ‰çš„é”®ï¼Œæ‰€æœ‰çš„å€¼åˆ†åˆ«æ‰“åŒ…å­˜æ”¾åœ¨å„è‡ªçš„æ¡¶ä¸­ã€‚ å½“æˆ‘ä»¬éåŽ†ä¸€ä¸ªmapçš„æ—¶å€™ï¼Œè¿­ä»£å™¨ä¾æ¬¡è®¿é—®æ‰€æœ‰çš„æ¡¶ï¼Œç„¶åŽæŒ‰ç…§å®ƒä»¬åœ¨å­—èŠ‚æ•°ç»„ä¸­çš„é¡ºåºä¾æ¬¡è¿”å›žé”®å€¼å¯¹ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆmapçš„è¾“å‡ºæ˜¯æ— åºé›†åˆã€‚hash keyså†³å®šäº†mapçš„éåŽ†é¡ºåºï¼Œå› ä¸ºå®ƒä»¬å†³å®šäº†æ¯ä¸ªé”®å€¼å¯¹æœ€ç»ˆä¼šè¿›å…¥å“ªä¸ªæ¡¶ã€‚ 4. å†…å­˜å’Œæ¡¶æº¢å‡ºé”®å€¼å¯¹ä¹‹æ‰€ä»¥è¦è¿™æ ·æ‰“åŒ…å­˜æ”¾åœ¨ä¸€ä¸ªå­—èŠ‚æ•°ç»„ä¸­ï¼Œæœ‰ä¸€ä¸ªå¾ˆé‡è¦çš„åŽŸå› ã€‚é‚£å°±æ˜¯ï¼Œå‡å¦‚æ‰€æœ‰çš„é”®ã€å€¼éƒ½æŒ‰ç…§key/value/key/valueçš„æ–¹å¼å­˜å‚¨ï¼Œåœ¨æ¯ä¸ªé”®å€¼å¯¹ä¹‹é—´å°±éœ€è¦åŽ»é¢å¤–å¡«å……é€‚å½“çš„ç©ºé—´ï¼Œæ‰èƒ½å¤Ÿä¿æŒå†…å­˜è¾¹ç•Œå¯¹é½ã€‚ä¸¾ä¸ªðŸŒ°ï¼Œæˆ‘ä»¬ç”³æ˜Žå¦‚ä¸‹è¿™æ ·çš„ä¸€ä¸ªmapï¼š 1map[int64]int8 è¿™ä¸ªmapçš„æ¯ä¸€ä¸ªé”®å€¼å¯¹ä¸­ï¼Œä¸€ä¸ªå­—èŠ‚å¤§å°çš„å€¼éƒ½ä¼šå¯¼è‡´7ä¸ªå­—èŠ‚çš„é¢å¤–å¡«å……ã€‚è€Œé€šè¿‡å°†é”®å€¼å¯¹ä»¥key/key/value/valueçš„æ–¹å¼å­˜å‚¨ï¼Œå”¯ä¸€å¯èƒ½éœ€è¦é¢å¤–å¡«å……çš„åœ°æ–¹å°±æ˜¯åœ¨å­—èŠ‚æ•°ç»„çš„æœ€åŽï¼Œè€Œä¸æ˜¯ä¹‹é—´ã€‚æ¶ˆé™¤è¿™äº›ä¸å¿…è¦çš„å¡«å……å­—èŠ‚ï¼Œå¸®åŠ©æ¡¶å’Œmapçœäº†å¾ˆå¤šçš„å†…å­˜å¼€é”€ã€‚æƒ³è¦å­¦ä¹ æ›´å¤šè¾¹ç•Œå¯¹é½ç›¸å…³çš„çŸ¥è¯†ï¼Œå¯ä»¥è¯»è¯»è¿™ç¯‡æ–‡ç« ã€‚ æ¯ä¸ªæ¡¶é…ç½®æˆäº†åªèƒ½å­˜å‚¨8ä¸ªé”®å€¼å¯¹ã€‚å¦‚æžœæœ‰ç¬¬ä¹ä¸ªé”®å€¼å¯¹éœ€è¦åŠ å…¥åˆ°è¿™ä¸ªå·²ç»æ»¡äº†çš„æ¡¶ä¸­æ—¶ï¼Œä¸€ä¸ªæ–°çš„æ¡¶å°±ä¼šè¢«åˆ›å»ºï¼Œå¹¶è¢«å„è‡ªçš„æ¡¶æ‰€å¼•ç”¨ã€‚ 5. mapæ‰©å®¹å½“æˆ‘ä»¬æŒç»­çš„å¯¹ä¸€ä¸ªmapæ·»åŠ /åˆ é™¤é”®å€¼å¯¹æ—¶ï¼Œmapçš„æ€§èƒ½ä¼šå¼€å§‹ä¸‹é™ã€‚å†³å®šäº†ä¸€ä¸ªmapä½•æ—¶è§¦å‘æ‰©å®¹çš„è´Ÿè½½é˜ˆå€¼æ˜¯ç”±ä»¥ä¸‹å››ä¸ªå› å­å†³å®šçš„ï¼š 1234overflow : Percentage of buckets which have an overflow bucketbytes/entry : Number of overhead bytes used per key/value pairhitprobe : Number of entries that need to be checked when looking up a keymissprobe : Number of entries that need to be checked when looking up an absent key ç›®å‰ï¼Œæºç ä¸­ç”¨çš„å…·ä½“çš„è´Ÿè½½é˜ˆå€¼å¦‚ä¸‹ï¼š LOAD %overflow bytes/entry hitprobe missprobe 6.50 20.90 10.79 4.25 6.50 å‘ç”Ÿæ‰©å®¹æ—¶ï¼Œé¦–å…ˆç”³è¯·ä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘æ—§æ¡¶çš„åœ°å€ã€‚ç„¶åŽåˆ†é…ä¸€ä¸ªäºŒå€äºŽåŽŸæ¥æ¡¶æ•°é‡çš„æ¡¶æ•°ç»„ã€‚è¿™ä¼šå¯¼è‡´å‡ºçŽ°å¤§é‡çš„å†…å­˜åˆ†é…ï¼Œä½†æ˜¯å› ä¸ºè¿™äº›ç”³è¯·çš„å†…å­˜å¹¶æ²¡æœ‰åˆå§‹åŒ–ï¼Œæ‰€ä»¥è¿™äº›åˆ†é…æ—¶å¾ˆå¿«çš„ã€‚ ä¸€æ—¦æ–°çš„æ¡¶æ•°ç»„çš„å†…å­˜å¯ç”¨äº†ï¼Œæ—§çš„æ¡¶æ•°ç»„ä¸­çš„æ‰€æœ‰é”®å€¼å¯¹å°±å¯ä»¥æ¬åˆ°æ–°çš„æ¡¶æ•°ç»„ä¸­åŽ»äº†ã€‚æ¯æ¬¡æ¬è¿å‘ç”Ÿåœ¨mapæ–°å¢ž/ç§»é™¤é”®å€¼å¯¹çš„æ—¶å€™ã€‚åœ¨æ—§æ¡¶æ•°ç»„ä¸­çš„åŒä¸€ä¸ªæ¡¶çš„é”®å€¼å¯¹å¯èƒ½è¢«æ¬è¿åˆ°æ–°æ¡¶æ•°ç»„çš„ä¸åŒçš„æ¡¶ä¸­åŽ»ã€‚æ¬è¿ç®—æ³•è¯•å›¾è®©é”®å€¼å¯¹å‡åŒ€çš„åˆ†å¸ƒåœ¨æ–°çš„æ¡¶æ•°ç»„ä¸­ã€‚ è¿™æ˜¯ä¸€ä¸ªéžå¸¸ç²¾å·§çš„è®¾è®¡ï¼Œå› ä¸ºè¿­ä»£å™¨ä»ç„¶éœ€è¦åŽ»éåŽ†æ—§çš„æ¡¶ï¼Œç›´åˆ°æ—§çš„æ¡¶å…¨éƒ¨æ¬è¿å®Œæ¯•ã€‚åœ¨è¿­ä»£æ“ä½œçš„è¿‡ç¨‹ä¸­ï¼Œé”®å€¼å¯¹çš„è¿”å›žæ–¹å¼ä¹Ÿå—åˆ°äº†è¿™ä¸€è®¾è®¡çš„å½±å“ã€‚é‡‡ç”¨äº†å¾ˆå¤šæ–¹æ¡ˆæ¥ç¡®ä¿åœ¨mapæ‰©å®¹çš„è¿‡ç¨‹ä¸­è¿­ä»£å™¨èƒ½æ­£å¸¸å·¥ä½œã€‚ 6. æ€»ç»“æ­£å¦‚å¼€å¤´æ‰€è¯´çš„ï¼Œè¿™ç¯‡æ–‡ç« åªæ˜¯åœ¨ä¸€ä¸ªå®è§‚çš„è§†è§’ä¸‹çœ‹mapçš„å†…éƒ¨ç»“æž„å’Œå®ƒæ˜¯å¦‚ä½•æ‰©å®¹çš„ã€‚æºç æ˜¯ç”¨cå†™çš„ï¼Œä½¿ç”¨äº†å¾ˆå¤šçš„å†…å­˜å’ŒæŒ‡é’ˆæ“ä½œæ¥ä¿è¯æ•ˆçŽ‡å’Œå¯é ã€‚ å½“ç„¶äº†ï¼ŒçŽ°åœ¨çš„å®žçŽ°æ–¹å¼åœ¨æœªæ¥çš„ä»»ä½•ä¸€ä¸ªæ—¶é—´éƒ½å¯èƒ½ä¼šå‘ç”Ÿæ”¹å˜ã€‚ä½†æ˜¯è¿™å¹¶ä¸å½±å“æˆ‘ä»¬æ­£ç¡®ä½¿ç”¨mapçš„èƒ½åŠ›ã€‚è¿™ä¸ªè§†è§’è®©æˆ‘ä»¬æ˜Žç™½äº†ï¼Œå½“æˆ‘ä»¬æå‰çŸ¥é“ä¼šæœ‰å¤šå°‘keyéœ€è¦å­˜å‚¨æ—¶ï¼Œæœ€å¥½åœ¨åˆå§‹åŒ–çš„æ—¶å€™å°±æŠŠç›¸åº”å¤§å°çš„å†…å­˜åˆ†é…å¥½ã€‚åŒæ—¶ä¹Ÿè§£é‡Šäº†ä¸ºä»€ä¹ˆmapæ˜¯ä¸€ä¸ªæ— åºçš„é›†åˆï¼Œå’Œä¸ºä»€ä¹ˆåœ¨éåŽ†mapçš„æ—¶å€™ï¼Œè¿­ä»£å™¨çš„è¡Œä¸ºçœ‹èµ·æ¥åƒæ˜¯éšæœºçš„ã€‚ æ­¤æ–‡ä¸ºè¯‘æ–‡ï¼ŒåŽŸæ–‡åœ°å€ã€‚]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>map</tag>
        <tag>internals</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golangä¸­sliceçš„ä½¿ç”¨æŠ€å·§]]></title>
    <url>%2Farticles%2FGolang%E4%B8%ADslice%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[ç”±äºŽå¼•å…¥äº†å†…å»ºçš„appendæ–¹æ³•ï¼Œcontainer/vectoråŒ…çš„å¾ˆå¤šæ–¹æ³•åœ¨Go 1ä¸­è¢«ç§»é™¤äº†ï¼Œå› ä¸ºæˆ‘ä»¬è®¤ä¸ºå¯ä»¥é€šè¿‡ä½¿ç”¨appendå’Œcopyæ¥ä»£æ›¿å®ƒä»¬ã€‚ ä¸‹é¢å°±æ˜¯container/vectoråŒ…ä¸­çš„æ–¹æ³•ï¼Œæˆ‘ä»¬é€šè¿‡sliceæ¥æ¨¡æ‹Ÿå®žçŽ°ã€‚ å¸¸è§„æ“ä½œ1. Append Vector1a = append(a, b...) 2. Copy123456b = make([]T, len(a))copy(b, a)// orb = append([]T(nil), a...)// orb = append(a[:0:0], a...) // æŸ¥çœ‹ https://github.com/go101/go101/wiki 3. Cut1a = append(a[:i], a[j:]...) 4. Delete123a = append(a[:i], a[i+1:]...)// ora = a[:i+copy(a[i:], a[i+1:])] 5. Delete without preserving order12a[i] = a[len(a)-1] a = a[:len(a)-1] æ³¨æ„: å¦‚æžœè¯¥å…ƒç´ ç±»åž‹æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼Œæˆ–è€…æ˜¯ä¸€ä¸ªåŒ…å«éœ€è¦è¢«å›žæ”¶çš„æŒ‡é’ˆç±»åž‹å­—æ®µçš„structï¼Œä¸Šé¢çš„cutã€deleteå®žçŽ°å¯èƒ½ä¼šæœ‰æ½œåœ¨çš„å†…å­˜æ³„æ¼çš„é—®é¢˜ã€‚ä¸€äº›å…ƒç´ çš„å€¼å¯èƒ½ä¼šè¢«aä¸€ç›´å¼•ç”¨è€Œä¸è¢«é‡Šæ”¾ï¼Œä¸‹é¢çš„ä»£ç å¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚ 12345678910111213141516// Cutcopy(a[i:], a[j:])for k, n := len(a)-j+i, len(a); k &lt; n; k++ &#123; a[k] = nil // æˆ–è€…ç±»åž‹Tçš„å¯¹åº”é›¶å€¼&#125;a = a[:len(a)-j+i]// Deletecopy(a[i:], a[i+1:])a[len(a)-1] = nil // æˆ–è€…ç±»åž‹Tçš„å¯¹åº”é›¶å€¼a = a[:len(a)-1]// ä¸ä¿è¯åŽŸæ¥é¡ºåºçš„Deletea[i] = a[len(a)-1]a[len(a)-1] = nila = a[:len(a)-1] 6. Expand1a = append(a[:i], append(make([]T, j), a[i:]...)...) 7. Extend1a = append(a, make([]T, j)...) 8. Insert1a = append(a[:i], append([]T&#123;x&#125;, a[i:]...)...) æ³¨æ„: ç¬¬äºŒä¸ªappendï¼ˆæŒ‡çš„ðŸ‘†ä»£ç å—çš„ä¸­append([]T{x}, a[i:]...)ï¼‰ä¼šåˆ©ç”¨åŽŸæ¥sliceåº•å±‚çš„æ•°ç»„åˆ›å»ºä¸€ä¸ªæ–°çš„sliceï¼Œç„¶åŽå°†a[i:]ä¸­çš„å…ƒç´ copyåˆ°è¿™ä¸ªæ–°çš„sliceï¼Œæœ€åŽå†æŠŠè¿™ä¸ªæ–°çš„sliceå¤åˆ¶å›žåŽŸæ¥çš„aã€‚ æ–°çš„sliceçš„åˆ›å»ºï¼ˆéšä¹‹å¸¦æ¥äº†å¤šä½™çš„å†…å­˜å›žæ”¶åŽ‹åŠ›ï¼‰å’Œcopyå¯ä»¥ä½¿ç”¨ä¸‹é¢çš„æ–¹å¼æ¥é¿å…ï¼š 1234// Inserts = append(s, 0)copy(s[i+1:], s[i:])s[i] = x 9. InsertVector1a = append(a[:i], append(b, a[i:]...)...) 10. Pop/Shift1x, a = a[0], a[1:] 11. Pop Back1x, a = a[len(a)-1], a[:len(a)-1] 12. Push1a = append(a, x) 13. Push Front/Unshift1a = append([]T&#123;x&#125;, a...) ä¸€äº›å¥‡æŠ€æ·«å·§ï¼ˆå‰æ–¹é«˜èƒ½â€¦â€¦orzï¼‰1. æ— é¢å¤–å¯¹è±¡åˆ†é…çš„filterè¿™ä¸ªæŠ€å·§åˆ©ç”¨äº†sliceä¼šå…±äº«å®ƒåº•å±‚æ•°æ®å­˜å‚¨å’Œå®¹é‡çš„ç‰¹æ€§ï¼Œé€šè¿‡é‡ç”¨åº•å±‚å­˜å‚¨æ¥è¿‡æ»¤sliceã€‚å½“ç„¶äº†ï¼ŒåŽŸsliceçš„å†…å®¹ä¹Ÿä¼šç›¸åº”å‘ç”Ÿæ”¹å˜ã€‚ 123456b := a[:0]for _, x := range a &#123; if f(x) &#123; b = append(b, x) &#125;&#125; 2. åè½¬å°†sliceä¸­çš„å…ƒç´ åè½¬ã€‚ 1234for i := len(a)/2-1; i &gt;= 0; i-- &#123; opp := len(a)-1-i a[i], a[opp] = a[opp], a[i]&#125; ä¸‹é¢çš„ä»£ç ç±»ä¼¼ï¼Œåªä¸è¿‡ä½¿ç”¨äº†ä¸¤ä¸ªæ¸¸æ ‡ã€‚ 123for left, right := 0, len(a)-1; left &lt; right; left, right = left+1, right-1 &#123; a[left], a[right] = a[right], a[left]&#125; 3. æ´—ç‰ŒFisherâ€“Yatesç®—æ³•ã€‚ ä»Žgo1.10å¼€å§‹ï¼Œå·²ç»åœ¨åŒ…math/rand.Shuffleä¸­åŽŸç”Ÿæ”¯æŒäº†ã€‚ 1234for i := len(a) - 1; i &gt; 0; i-- &#123; j := rand.Intn(i + 1) a[i], a[j] = a[j], a[i]&#125; 4. æœ€å°åŒ–å†…å­˜ä½¿ç”¨çš„æ‰¹é‡å¤„ç†æ–¹æ³•å¦‚æžœä½ æƒ³åˆ†æ‰¹å¤„ç†ä¸€ä¸ªå¾ˆå¤§çš„sliceï¼Œè¿™ä¸ªæŠ€å·§ä¼šå¾ˆæœ‰ç”¨ï¼ 1234567891011actions := []int&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;batchSize := 3var batches [][]intfor batchSize &lt; len(actions) &#123; actions, batches = actions[batchSize:], append(batches, actions[0:batchSize:batchSize])&#125;batches = append(batches, actions)fmt.Println(result)// [[0 1 2] [3 4 5] [6 7 8] [9]] 5. in-place åŽ»é‡æ³•123456789101112131415import "sort"in := []int&#123;3,2,1,4,3,2,1,4,1&#125; // ä»»ä½•å®žçŽ°äº†sortæŽ¥å£çš„ç±»åž‹éƒ½å¯ä»¥sort.Ints(in)j := 0for i := 1; i &lt; len(in); i++ &#123; if in[j] == in[i] &#123; continue &#125; j++ in[i], in[j] = in[j], in[i]&#125;result := in[:j+1]fmt.Println(result) // [1 2 3 4] æ³¨ï¼šæœ¬æ–‡æºè‡ªGolangå®˜æ–¹Wikiæ–‡ç« ï¼Œä¸”åœ¨ä¸å®šæœŸæ›´æ–°ï¼Œæœ¬äººä¹Ÿä¼šæŒç»­è·Ÿè¿›ï½ž]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>slice</tag>
        <tag>tricks</tag>
      </tags>
  </entry>
</search>
